<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>동기와 비동기_동기식</title>
</head>
<body>
    <!-- 
         * 동기와 비동기
         : 프로그램이 동작하는 상태에서 완전히 해당 내용을 끝내고 
         다음으로 제어를 넘기는 방식을 동기식,
         
         동작이 끝나지 않은 상태에서도 제어권을 넘긴 후 프로그램을 계속 진행하면
         비동기식이라 함

         예외 처리(Exception)
         : 프로그램이 실행되고 있는 런타임 시에 에러가 발생할 경우 처리할 수 있는 프로그램 구간을 의미

         try{
            예외 상황이 발생할 수 있는 문장
            ...
            ...
         }catch(e){
            예외 상황이 발생했을 경우 처리할 문장(e는 Exception 객체)
         }finally{
            예외 상황이 발생하거나 발생하지 않아도 
            무조건 실행될 문장(생략가능)
         }
    -->
<script>
    function workP(sec){
        /*
            promise : 많은 콜백 함수를 사용하다보면 코드가 복잡하게 중복이 되는 경우가 생김
            -> 콜백 함수 발생

            코드의 중첩이 많아지는 콜백의 지옥에서 벗어나게 해주는 객체

            promise의 인스턴스를 return하고
            then에서 return한 것을 받는다
        */

        return new Promise((resolve, reject) =>{   // 서버에 요청과 응답
            // Promise 생성 시에 넘기는 callback = resolve, reject
            // resolve : 동작 완료시 호출, reject : 에러 발생 시 호출

            setTimeout(() => {
               resolve(new Date().toISOString()); // 동작이 성공하면 resolve에 값이 담긴다??
            }, sec*1000);
        });
    };
    
    workP(1).then((result)=>{   // then이 return이라고. 그러면 workP()함수의 결과(return의 값)을 
                                // then 안에 있는 result에 담기게 된다
        console.log('첫번째 작업', result);
        return workP(1);    // 다시 함수를 호출하는거라고하네
    }).then((result)=>{     // 그래서 위의 return의 결과값을 .then((result))에 result 변수에 담기게 된다고
        console.log('두번째 작업', result);
    });
 
    // console
    // 첫번째 작업 현재 시간
    // 두번째 작업 현재 시간

    /* 
        함수호출
        var 변수 = abs();

        function abs(){

            return 변수 = 실행문;
        }
    */
</script>
</body>
</html>